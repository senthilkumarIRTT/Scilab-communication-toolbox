function y = dpskmod(x,M,varargin)
//DPSKMOD Differential phase shift keying modulation.
//   Y = DPSKMOD(X,M) outputs the complex envelope of the modulation of the
//   message signal X using differential phase shift keying modulation.  M
//   is the alphabet size and must be an integer. The message signal must
//   consist of integers between 0 and M-1. For two-dimensional signals, the
//  function treats each column as 1 channel.
//   Y = DPSKMOD(X,M,PHASEROT) specifies the phase rotation (rad) of the
//   modulation. In this case, the total per-symbol phase shift is the sum
//   of PHASEROT and the phase generated by the differential modulation.
//   Y = DPSKMOD(X,M,PHASEROT,SYMBOL_ORDER) specifies how the function 
//   assigns binary words to corresponding integers. If SYMBOL_ORDER 
//   is set to 'bin' (default), then the function uses a natural binary-coded 
//   ordering. If SYMBOL_ORDER is set to 'gray', then the function uses 
//   a Gray-coded ordering.
// error checks
[ll,rr]= argn(0);
funcprot(0);
if rr<2 then
    error('comm:dpskmod:numarg1');
end
if rr>4 then
	error('comm:dpskmod:numarg2');
end
//Check x, phaserot
if(~isreal(x)|or(or(ceil(x)~=x))|~or(type(x)==[1 5 8]))
    error('comm:dpskmod:Xreal');
end

if(~isreal(M)|~isscalar(M)|M<=0|(ceil(M)~=M)|~or(type(M)==[1 5 8]))
    error('comm:dpskmod:Mreal');
end
//check that X are all integers within range.
if (min(min(x)) < 0)|(max(max(x))>(M-1))
    error('comm:dpskmod:Xreal');
end
if(rr>=3)
    Phase_Rotation = varargin(1);
    if(isempty(Phase_Rotation))
        Phase_Rotation = 0;
    elseif(~isreal(Phase_Rotation)|~isscalar(Phase_Rotation)|~or(type(Phase_Rotation)==[1 5 8]))
        error('comm:dpskmod:phaserotreal');
    end
else 
    Phase_Rotation = 0;
end
// Check SYMBOL_ORDER
if(rr==2|rr==3)    
   Symbol_Ordering = 'bin'; //default
else
    Symbol_Ordering = varargin(2);
    if(~type(Symbol_Ordering)==10)|(~strcmpi(Symbol_Ordering,'GRAY'))&(~strcmpi(Symbol_Ordering,'BIN'))
        error('comm:dpskmod:SymbolOrder');    
    end
end
disp(Symbol_Ordering,'Symbol order')
//--- Assure that X, if one dimensional, has the correct orientation --- 
wid = size(x,1);
disp(x,'x=')
if(wid ==1)
    x = x(:);
end
disp(x,'x=')
//Gray encode if necessary
if(Symbol_Ordering='GRAY')
    [x_gray,gray_map] = bin2gray(x,'DPSK',M);   // Gray encode
    gray_map = double(gray_map);
    disp(type(x))
    disp(type(gray_map))
    [tf,index]=members(x,gray_map);
     x=index-1;
end    
// Create a vector for the output.
Phase_Constellation = (2*%pi*(0:M-1)/M)';
disp(Phase_Constellation)
// Calculate phase of the DPSK modulated signal
disp(x)
disp(x+1)
yPhase = cumsum(Phase_Rotation + Phase_Constellation(x+1));
disp(yPhase)
// Calculate baseband signal
y = exp(%i*yPhase);
disp(y)
//modulator output must be complex
if isreal(y)
    y = complex(y,0);
end
disp(y)
// --- restore the output signal to the original orientation 
if(wid == 1)
    y = y.';
end
disp(y)
//EOF
endfunction
////////////////////////////////////////////////////////////////////////////
